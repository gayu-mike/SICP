Exercise 1.25
==============

.. code-block:: scheme

    ; Our expmod
    (define (expmod base exp m)
        (cond ((= exp 0) 1)
              ((even? exp) (remainder
                                (square (expmod base (/ exp 2) m))
                                 m))
              (else (remainder (* base (expmod base (- exp 1) m)) m))
        )
    )

    ; Alyssa P. Hacker's expmod
    (define (expmod base exp m)
        (remainder (fast-expt base exp) m)
    )
    (define (fast-expt b n)
        (cond ((= n 0)
                1)
              ((even? n)
                (square (fast-expt b (/ n 2)))
              )
              (else
                (* b (fast-expt b (- n 1)))
              )
        )
    )

我们取一些比较小的值来观察两个过程的估算情况（这种方法非常常用）：

.. code-block:: scheme

    ; 7^8 mod 8
    (% (expmod 7 4 8)^2 8)
    (% (% (expmod 7 2 8)^2 8)^2 8)
    (% (% (% (expmod 7 1 8)^2 8)^2 8)^2 8)
    (% (% (% (* 7 (expmod 7 0 8) 8)^2 8)^2 8)^2 8)
    (% (% (% (% 7 1)^2 8)^2 8)^2 8)^2 8)^2 8)
    (% (% (% (% 1^2 8)^2 8)^2 8)^2 8)
    (% (% (% 1^2 8)^2 8)^2 8)
    (% (% 1^2 8)^2 8)
    (% 1^2 8)


    (% (exp 7 8) 8)
    (% (exp 7 4)^2 8)
    (% (exp 7 2)^2^2 8)
    (% (exp 7 1)^2^2^2 8)
    (% (* 7 (exp 7 0))^2^2^2 8)
    (% (* 7 1)^2^2^2 8)
    (% 7^2^2^2 8)
    (% 49^2^2 8)
    ...

可以看到，理论上使用 ``fast-exp`` 的时间、空间复杂度和 ``expmod`` 是一样的，
**但两者计算的值的大小不一样。**

因为前者每次都计算 ``remainder`` 再算 ``square`` ，
而后者在递归估算的每一步都作平方运算。一旦需要测试的素数很大，就会超过 
*mit-scheme* 的计算能力。

因此在实际中， ``expmod`` 实用性更强。