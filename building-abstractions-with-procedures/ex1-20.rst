Exercise 1.20
==============

.. notice::
    为了少打几个字，使用了 ``r`` 替换 ``remainder``

使用正则序的 ``gcd``

.. code-block:: scheme

    (gcd 206 40)
    ; (if (= 40 0) ..
    (gcd 40 (r 206 40))
    ; (if (= 6 0) ..
    (gcd (r 206 40) (r 40 (r 206 40)))
    ; (if (= 4 0) ..
    (gcd (r 40 (r 206 40)) (r (r 206 40) (r 40 (r 206 40))))
    ; (if (= 2 0) ..
    (gcd (r (r 206 40) (r 40 (r 206 40))
            (r (r 40 (r 206 40))
               (r (r 206 40) (r 40 (r 206 40)))))
    ; (if (= 0 0)
    ;       (r (r 206 40) (r 40 (r 206 40))))

因为使用正则序来解释程序的情况下，``remainder`` 只做展开，
在需要求值的时候调用（包括题目特别指出的 ``if`` 语句中）。
因此要算求值 ``(r (r 206 40) (r 40 (r 206 40)))`` 中的 4 个 r，
以及之前每个 ``(if (= b 0) a)`` 中的 b 部分（总计 14 次）。

**因此答案是 18**

如果采用应用序求解，调用情况如下：

.. code-block:: scheme

    (gcd 206 40)
    ; (gcd 40 (r 206 40))
    (gcd 40 6)
    ; (gcd 6 (r 40 6))
    (gcd 6 4)
    ; (gcd 4 (r 6 4))
    (gcd 4 2)
    ; (gcd 2 (r 4 2))
    (gcd 2 0)
    (if (= 0 0) 2)
    2

**所以采用应用序的调用次数是 4 。**
我们也很容易看到这个过程是迭代的
